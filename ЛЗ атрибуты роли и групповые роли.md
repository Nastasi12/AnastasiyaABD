####Часть 1. Атрибуты ролей в Postgres
Атрибуты необходимы для задания пользователю(роли) определённых полномочий.
Право на подключение даёт атрибут **LOGIN**. (по умолчанию присваивается, если использовать конструкцию **CREATE USER**)Я создала роль us_ch с атрибутом LOGIN:
![avatar](https://sun9-83.userapi.com/impg/hoGLopGUHBrbDCO-2O40DseDfW_TKxEn-RCB0g/Zjyzz6DGpAU.jpg?size=575x42&quality=96&sign=b63335dffd67cb104bbf2b1a111515f5&type=album)
Так же создала пользователя us_ch2, чтобы проверить, является ли атрибут LOGIN параметром по умолчанию:
![avatar](https://sun9-37.userapi.com/impg/mS2meoM3MVGG0_cumleaQVZ6Gaon_Nea7wAkGg/umCnYC4_C_Y.jpg?size=677x202&quality=96&sign=a91628185a4318b5bd293f64e7c47ff3&type=album)
Атрибут **SUPERUSER**(у пользователя postgres)даёт роли права супер пользователя. Однако этого делать не рукомендуется, так как это опасная привилегия и она не должна использоваться небрежно.
Роль должна иметь разрешение на создание базы данных,таблиц и т.д. (за исключением суперпользователей, которые пропускают все проверки).
 Для задания роли такого атрибута я использовала следующую команду **ALTER ROLE имя CREATEDB**.
![avatar](https://sun9-8.userapi.com/impg/B6d07IWeWMB-hSvLoGnfk83UqvdrJM6QHUkOHA/oVIm68mrGRg.jpg?size=722x180&quality=96&sign=0ef31a1902293f2168acb7b86ab07fc1&type=album)
Теперь дадим роли атрибут на использование протокола репликации( **ALTER ROLE имя роли REPLICATION**), так как роль должна иметь явное разрешение на запуск потоковой репликации. Роль, используемая для потоковой репликации, также должна иметь атрибут LOGIN(В нашем случае он уже есть):
![avatar](https://sun9-22.userapi.com/impg/kY8b3A8zKlwteZDzwoO7xXFee5hBzhe0Ouw4AQ/uAn7j8moxTs.jpg?size=690x165&quality=96&sign=5dff890feb549d4efd1b40b2fa536830&type=album)
Теперь роль us_ch обладает выше перечисленными правами.
#### Членство в другой роли
Часто у многих пользователей могут быть одни и те же права, для того чтобы оптимизовать процесс задания этих прав, роли группируются, права можно выдавать для всей группы и у всей группы забирать. В Postgres для этого создаётся роль, представляющая группу, а затем членство в этой группе выдаётся ролям индивидуальных пользователей.Обычно групповая роль не имеет атрибута LOGIN, хотя при желании его можно установить.
Я удалила роль us_ch2:
![avatar](https://sun9-39.userapi.com/impg/dOBKo8qQ3Azvmz9QS0zdQMVoxiOEuURSR39HrA/5lXSeenD3JI.jpg?size=657x147&quality=96&sign=e8fc56a2c8a63af60a1308ffaf927456&type=album)
В качестве групповой будет выступать роль us_ch2, мы можем добавлять в неё членов или удалять их, используя команды **GRANT** и **REVOKE**.
Я создадала ещё одну роль и предоставила ей членство в групповой роли.
![avatar](https://sun9-35.userapi.com/impg/b380cuhWoiJ15T5AQpId0kL9fJPGXbjiTyD_GQ/Jiw475VnKEw.jpg?size=640x195&quality=96&sign=bf225cf49dd02a717a5fb92dd60400eb&type=album)
Таким же образом мы можем давать права на изменения в определённых таблицах или даже столбцах(Например давать права только чтения из таблиц).
Лишение роли прав осуществляется командой **REVOKE**, однако сделать это может пользователь, который дал это право(В нашем случае это postgres). Таким образом я забрала права у пользователя:
![avatar](https://sun9-11.userapi.com/impg/aC3jMUJ4uS9U4f6s90DzXP1fN547yKdNhAg9Xw/DKoken78C6M.jpg?size=631x168&quality=96&sign=7590ffd02b698de1f06107e543c632c6&type=album)


